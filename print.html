<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust in Pieces</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/extra.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust in Pieces</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/thedataquarry/rustinpieces" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust-in-pieces"><a class="header" href="#rust-in-pieces">Rust in Pieces</a></h1>
<p>A top-down approach to learning Rust coming from Python (and vice-versa).</p>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>This book's goal is to bring the Python and Rust developer communities closer together, and to help more developers from one language learn how to leverage the benefits of the other.</p>
<p>The book and accompanying <a href="https://github.com/thedataquarry/rustinpieces">code</a> are organized into a collection of small projects, termed <em>pieces</em>. Each piece is a self-contained task with Python and Rust implementations that each perform the same task. The aim is to help Python developers gain familiarity with Rust, and vice-versa, by comparing and contrasting the two languages in a top-down manner.</p>
<p>Importantly, the pieces in this book build towards <strong>unifying Python and Rust code bases</strong> via <a href="https://github.com/PyO3/pyo3">PyO3</a>, a highly popular open source library that allows you to call Rust bindings from Python or the Python interpreter from Rust. <em>Using one language does not preclude using the other!</em></p>
<p>As you go through the pieces, you'll find yourself becoming proficient in writing clean, tested, production-worthy code using engineering best practices in either language, moving between them at will. Over time, you can make a more informed choice regarding when to use one or the other language for parts of a larger project.</p>
<p>We believe that Rust 🦀 is the among the most approachable lower-level programming languages for Python developers, and that Python is one of the most valuable high-level languages for Rust developers who are looking to build tooling for the burgeoning data, AI and ML ecosystems. The arrival of tools like PyO3 has made it highly feasible for a developer to straddle both worlds, combining their best parts, thus helping build more efficient and scalable software.</p>
<h2 id="whats-covered-in-this-book"><a class="header" href="#whats-covered-in-this-book">What's covered in this book?</a></h2>
<p>Rust's learning curve is considerably steeper than Python's, so the table below is provided to show a mapping between each piece and its corresponding concept in Rust. As can be seen, structs, serialization, deserialization, vectors and traits are ubiquitous concepts in Rust.</p>
<div class="table-wrapper"><table><thead><tr><th>Piece</th><th>Category</th><th>Key Rust concepts</th></tr></thead><tbody>
<tr><td>Hello world</td><td>Intro</td><td>macros</td></tr>
<tr><td>Data structures &amp; constructs</td><td>Intro</td><td>crates, structs, traits, implementations</td></tr>
<tr><td>Simple CSV parsing</td><td>Files</td><td>serde, vec</td></tr>
<tr><td>Regex JSON</td><td>Files</td><td>match, regex</td></tr>
<tr><td>Mock data generation</td><td>Files</td><td>RNG, sampling</td></tr>
<tr><td>Age grouping</td><td>Files</td><td>enums</td></tr>
<tr><td>Datetime parsing</td><td>Files</td><td>chrono, lifetimes</td></tr>
<tr><td>Extract pronouns from text</td><td>Files</td><td>rayon, parallelism</td></tr>
<tr><td>Postgres</td><td>Databases</td><td>async, sqlx, tokio</td></tr>
<tr><td>Meilisearch</td><td>CLIs</td><td>async, async-std, clap</td></tr>
<tr><td>REST API to Postgres</td><td>APIs</td><td>axum, async, tokio</td></tr>
<tr><td>PyO3 mock data generation</td><td>Unification</td><td>PyO3, Maturin</td></tr>
<tr><td>PyO3 parallel computation</td><td>Unification</td><td>PyO3, Maturin</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="why-use-rust-with-python"><a class="header" href="#why-use-rust-with-python">Why use Rust with Python?</a></h1>
<p><a href="https://www.python.org/">Python</a> is a dynamically typed, interpreted programming language that's known for its flexibility, ease of use and low barrier to entry. It's by far the most popular language for AI, ML and data science, and has been the go-to language for researchers and innovators in these fields for quite a while now.</p>
<p>It's possible to write relatively high-performance code in Python these days by leveraging its rich library ecosystem (which are typically wrappers around C/C++/Cython runtimes). However, performance and concurrency are <em>not</em> Python's strong suits, and this requires performance-critical code to be implemented in lower-level languages. For many Python developers, using languages like C, C++ and Cython is a daunting prospect.</p>
<p><a href="https://www.rust-lang.org/">Rust</a> is a statically typed, compiled programming language that's known for its relatively steep learning curve. Its design philosophy is centered around three core functions: performance, safety, and fearless concurrency. It offers a modern, high-level syntax and a rich type system that makes it possible to write code that runs really fast without the need for manual memory management, eliminating entire classes of bugs.</p>
<p>Although it's possible to write all sorts of complex tools and applications in Rust, it's not the best option for <em>every</em> situation. In cases like research and prototyping, where speed of iteration is important, Rust's strict compiler can slow down development, and Python is still the better choice.</p>
<p>We believe that Python 🐍 and Rust 🦀 form a near-perfect pair to address either side of the so-called "two-world problem", explained below.</p>
<h2 id="the-two-world-problem"><a class="header" href="#the-two-world-problem">The two-world problem</a></h2>
<p>The programming world often finds itself divided in two: those who prefer high-level, dynamically typed languages, and those who prefer low-level, statically typed languages.</p>
<p>Many high-level languages are interpreted (i.e., they execute each line as it's read, sequentially). These languages are generally easier to learn because they abstract away the details of memory management, allowing for rapid prototyping and development.</p>
<p>Lower-level languages, on the other hand, tend to be ahead-of-time (AOT) compiled. They offer the programmer more control over memory management, resulting in much more performant code at the cost of a steeper learning curve.</p>
<p>It's for these reasons that scientists, researchers, data scientists, data analysts, quants, etc. have traditionally preferred high-level languages like Python, R and Julia. On the other hand, systems programmers, OS developers, embedded systems engineers, game developers and software engineers tend to prefer lower-level languages like C, C++ and Rust.</p>
<p><img src="introduction//image/two-world-problem.png" alt="" /></p>
<p>The image above is a figurative representation of two distributions of people, typically disparate individuals from either background (with the languages listed in no specific order).</p>
<h2 id="has-the-two-world-problem-been-solved-before"><a class="header" href="#has-the-two-world-problem-been-solved-before">Has the two-world problem been solved before?</a></h2>
<p>A lot of readers will have heard of Julia, a dynamically typed, just-in-time (JIT) compiled alternative to Python and is often touted as a "high-level language with the performance of C". While Julia is no doubt a great language, it's popularity is largely limited to the scientific community and its library ecosystem and user community haven't yet matured to the extent that Python's has. As such, the "two-language problem" that Julia <a href="https://julialang.org/blog/2012/02/why-we-created-julia/">attempts to solve</a>, is still largely unsolved.</p>
<p>Other languages like Mojo explain in <a href="https://docs.modular.com/mojo/why-mojo.html">their vision</a> how they aim to solve the two-world problem by providing a single unified language (acting like a superset of Python) that can be compiled to run on any hardware. However, Mojo is still very much in its infancy as a language and hasn't gained widespread adoption, and its user community is non-existent.</p>
<h2 id="rust-and-pyo3"><a class="header" href="#rust-and-pyo3">Rust and PyO3</a></h2>
<p>The most interesting aspect about PyO3 in combination with Rust is that they offer a new way to think the two-world problem. Rather than trying to <em>solve</em> the problem by creating a new language that offers the best of many worlds, Rust and PyO3 <em>embrace</em> the problem by allowing a developer to move between the worlds and choose the best tool for parts of a larger task.</p>
<p>Rust's design philosophy and features make it an ideal candidate to bring people from these worlds (high-level and low-level languages) closer together. Rust's strict compiler, rich type system and ownership principles eliminate the need to manually manage memory without requiring a garbage collector, making it possible for a larger community of analytical and scientifically-minded developers to write high-performance code <em>without</em> sacrificing safety.</p>
<p><img src="introduction//image/two-world-problem-embraced.png" alt="" /></p>
<p>The image above shows a distribution of the same potential set of developers who can straddle both worlds. Those who are already proficient in Python and require fast iteration for prototyping can choose to write only very specific, performance-critical parts of their code in Rust. Conversely, those who are already proficient in Rust and require high-performance, safe code for their workflows can choose to interface with Python for only very specific parts that need access to the Python ecosystem.</p>
<p>In our view, the interface that PyO3 provides is <strong>fundamentally different</strong> from earlier approaches to interoperability with Python (such as pybind11, SWIG or Cython), because unlike the earlier tools, PyO3 and Rust are far more accessible to Python developers. We hope this becomes clearer and clearer as you progress through the book.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-approach-learning-a-new-language"><a class="header" href="#how-to-approach-learning-a-new-language">How to approach learning a new language</a></h1>
<p>Typically, the first steps in learning a programming language involve understanding its syntax, data structures and control flow expressions before tackling a specific problem. This is termed as <em>bottom-up</em> learning, and it's essential to understand the terminology of the language and its ecosystem.</p>
<p>Bottom-up learning resources typically include:</p>
<ul>
<li>Books</li>
<li>Documentation</li>
<li>Tutorials</li>
<li>Interactive exercises</li>
</ul>
<p>Although necessary to master a topic, bottom-up learning has the issue that learners often get stuck in <em>tutorial hell</em>, where they're constantly being exposed to new concepts without actually building anything end-to-end. In addition, bottom-up learning can leave learners frustrated because they're not able to see the bigger picture and how the different parts come together as a whole.</p>
<p>In contrast, top-down learning follows a more pragmatic approach that's grounded in the real-world. For this, a more abstract way of thinking is required. The learner identifies a problem statement in their domain and they learn <em>just enough</em> of the language to solve the problem at hand, going deeper only as needed.</p>
<p>Top-down learning resources typically include learning by example, using any of the following resources:</p>
<ul>
<li>Existing codebases</li>
<li>Blogs</li>
<li>Podcasts</li>
<li>Videos</li>
</ul>
<div class="warning">
<p>Top-down learning is not a replacement for bottom-up learning. The best way to become proficient and productive in a language is to <em>combine</em> both approaches and do them <em>together</em>.</p>
</div>
<h2 id="dont-reinvent-the-wheel"><a class="header" href="#dont-reinvent-the-wheel">Don't reinvent the wheel</a></h2>
<p>When learning a new language, it's tempting to start from scratch and build everything that's required to solve a problem from the ground up. This is a slow, sometimes painful process if you're just starting off, and can result in inefficient, unidiomatic code.</p>
<p>Both Rust and Python have rich package ecosystems, and this book leverages them to the fullest extent possible. After all, most great software is built on the shoulders of giants. Reading through existing codebases for libraries, tools and frameworks is a great way to learn how to write idiomatic code in a language, and to understand the performance implications of your code.</p>
<h2 id="prior-reading"><a class="header" href="#prior-reading">Prior reading</a></h2>
<p>It's recommended to have a basic understanding of Python and Rust before reading this book. If you're new to either language, consider reading the following resources. It's <strong>okay</strong> if you don't absorb everything in the first pass -- the goal is to get a high-level understanding of either language and their ecosystems.</p>
<ul>
<li><a href="https://nostarch.com/pythoncrashcourse2e">Python Crash Course</a> for hands-on Python concepts</li>
<li><a href="https://doc.rust-lang.org/book/">The Rust Book</a> and <a href="https://doc.rust-lang.org/rust-by-example/">Rust by Example</a> for an introduction to terminology and concepts in Rust</li>
<li><a href="https://github.com/rust-lang/rustlings">Rustlings</a> for a gentle introduction to compiling and running Rust code</li>
</ul>
<p>Once you have a handle on the terminology, you can start by getting your hands dirty with the pieces provided in this book. Or better yet, use this framework to create your own pieces for your domain of interest and start writing some code!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-read-this-book"><a class="header" href="#how-to-read-this-book">How to read this book</a></h1>
<p>The pieces are not meant to be read in a specific order. However, they are roughly organized in order of increasing complexity, and each piece, by and large, utilizes concepts that may have been introduced in an earlier piece.</p>
<p>One of the challenges with learning (and teaching) Rust, is that certain concepts such as ownership, borrowing, traits and lifetimes can be quite challenging to grasp for a new learner, but these concepts are ubiquitous in the language, such that they appear all at once. But, because the learning approach provided here is top-down, the best way to get familiar with these concepts is to try and apply them to your own projects, as done in each piece.</p>
<p>As such, we've tried to introduce these concepts in a way that's as gradual as possible, though it's still possible that you may find yourself having to refer to the <a href="https://doc.rust-lang.org/book/">Rust book</a> or other resources to understand certain concepts from the bottom-up as you go along.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup--installation"><a class="header" href="#setup--installation">Setup &amp; installation</a></h1>
<p>This section provides an opinionated guide to setting up your development environment for working with Rust and Python.
If you're an experienced developer in either language, feel free to skip this section.</p>
<h2 id="python"><a class="header" href="#python">Python</a></h2>
<p>For macOS/Linux users, it's recommended to manage Python versions using <a href="https://github.com/pyenv/pyenv">pyenv</a>. <code>pyenv</code> lets you easily switch between multiple versions of Python. It's simple, unobtrusive, and follows the UNIX tradition of single-purpose tools that do one thing well.</p>
<p>Follow the instructions from the <a href="https://github.com/pyenv/pyenv?tab=readme-ov-file#installation">installation steps</a> section of the README to install <code>pyenv</code> on your system.</p>
<p>Windows users can use <a href="https://github.com/pyenv-win/pyenv-win">pyenv-win</a>, a fork of <code>pyenv</code> that allows you to install and manage Windows-native Python versions.</p>
<h3 id="python-version"><a class="header" href="#python-version">Python version</a></h3>
<p>This book uses Python 3.11.x, though code run from Python 3.8+ should also work without issues. You can install the latest minor version using <code>pyenv</code>:</p>
<pre><code class="language-bash">pyenv install 3.11.7
</code></pre>
<h3 id="virtual-environments"><a class="header" href="#virtual-environments">Virtual environments</a></h3>
<p>It's recommended to use <a href="https://docs.python.org/3/tutorial/venv.html">virtual environments</a> to manage your Python dependencies. This allows you to create isolated environments for each project, and avoid dependency conflicts between projects.</p>
<p>The <code>venv</code> module is included in the Python standard library, so you don't need to install anything extra to use it.</p>
<p>To create a virtual environment on Unix systems, run the following command:</p>
<pre><code class="language-bash"># Setup a new environment for the first time
python -m venv venv
# Activate the environment
source venv/bin/activate
</code></pre>
<p>On Windows, it's more or less the same:</p>
<pre><code class="language-cmd">py -m venv .venv
.venv\Scripts\activate
</code></pre>
<p>You can deactivate the environment by running <code>deactivate</code> in your shell.</p>
<h2 id="rust"><a class="header" href="#rust">Rust</a></h2>
<p>For macOS/Linux users, <a href="https://doc.rust-lang.org/book/ch01-01-installation.html#installing-rustup-on-linux-or-macos">rustup</a> is the recommended to manage Rust versions. Using this tool, you can easily switch between multiple versions of Rust, and it also ships with the <code>cargo</code> package manager.</p>
<p>See the <a href="https://doc.rust-lang.org/book/ch01-01-installation.html#installing-rustup-on-windows">Rust Book</a> for instructions on how to install <code>rustup</code> on Windows.</p>
<h3 id="rust-version"><a class="header" href="#rust-version">Rust version</a></h3>
<p>This book uses Rust 1.75.x. You can install the latest minor version using <code>rustup</code>:</p>
<pre><code class="language-bash">rustup install 1.75.0
</code></pre>
<p>You can start a new Rust project in your local directory by running <code>cargo new &lt;project-name&gt;</code>, and you're ready to go!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pieces"><a class="header" href="#pieces">Pieces</a></h1>
<h2 id="what-is-the-purpose-of-each-piece"><a class="header" href="#what-is-the-purpose-of-each-piece">What is the purpose of each piece?</a></h2>
<p>A piece is a self-contained project with Python and Rust implementations that each perform the same tasks. The purpose of each piece is to help Python developers gain familiarity with Rust, and vice-versa, by comparing and contrasting the two languages in a top-down manner.</p>
<p>A piece's directory structure is organized as follows:</p>
<pre><code class="language-bash">pieces
├── intro
│   ├── python
│   │   ├── main.py
│   │   └── test_main.py
│   └── rust
│       ├── Cargo.toml
│       └── src
│           └── main.rs
├── hello_world
├── simple_csv
└── ...
</code></pre>
<p>Each piece comes with Python and Rust source code, and their associated tests. When using Rust's test client, test code is placed in the same file as the code it's testing, and is marked with the <code>#[cfg(test)]</code> attribute. When using Python's test client, test code is placed in a separate file, and is marked with the <code>test_</code> prefix.</p>
<p>For Python, <code>pip</code> is the package manager of choice, and <code>pytest</code> is the test client used throughout the code. For Rust, <code>cargo</code> is the package manager of choice, and Rust's inbuilt test client, invoked by <code>cargo test</code>, is used throughout.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello world!</a></h1>
<p>This is the conventional first program that you write when learning a new programming language. It's a simple program that prints the text <code>Hello, world!</code> to the console.</p>
<p>Navigate to the <code>pieces/hello_world</code> directory in the <a href="https://github.com/thedataquarry/rustinpieces/tree/main/pieces/hello_world">repo</a> to get started.</p>
<h2 id="python-1"><a class="header" href="#python-1">Python</a></h2>
<p>The file <code>main.py</code> has just one line of code:</p>
<pre><code class="language-python">print("Hello, world!")
</code></pre>
<p>The program is run as follows:</p>
<pre><code class="language-bash">python main.py
</code></pre>
<h2 id="rust-1"><a class="header" href="#rust-1">Rust</a></h2>
<p>The file <code>main.rs</code> has just three lines of code:</p>
<pre><code class="language-rs">fn main() {
    println!("Hello, world!");
}
</code></pre>
<p>The program is run via <code>cargo</code>:</p>
<pre><code class="language-bash">cargo run
</code></pre>
<h2 id="output"><a class="header" href="#output">Output</a></h2>
<pre><code class="language-bash">Hello, world!
</code></pre>
<h2 id="takeaways"><a class="header" href="#takeaways">Takeaways</a></h2>
<p>Rust's <code>println!</code> is similar to Python's <code>print</code> function, but it's a <strong>macro</strong>, not a function. It simply prints the standard output to the console followed by a newline character.</p>
<p>Macros are a powerful Rust feature that allow you to write code that writes other code. We'll see more examples of macros in later pieces, but for now, it's enough to know that in Rust, macros are invoked with an exclamation mark <code>!</code> at the end of their name.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h1>
<p>This piece is meant to be a quick introduction to simple constructs that are more or less similar between Python and Rust.</p>
<p>The following constructs are covered:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Python</th><th style="text-align: left">Rust</th></tr></thead><tbody>
<tr><td style="text-align: left">Protocols/special methods</td><td style="text-align: left">Traits</td></tr>
<tr><td style="text-align: left">Enumerate</td><td style="text-align: left">Enumerate</td></tr>
<tr><td style="text-align: left">Zip</td><td style="text-align: left">Zip</td></tr>
<tr><td style="text-align: left">Tuple</td><td style="text-align: left">Tuples</td></tr>
<tr><td style="text-align: left">Lambdas</td><td style="text-align: left">Closures</td></tr>
<tr><td style="text-align: left">List comprehensions</td><td style="text-align: left">Map/filter</td></tr>
<tr><td style="text-align: left">Dictionary</td><td style="text-align: left">HashMap</td></tr>
<tr><td style="text-align: left">Set</td><td style="text-align: left">HashSet</td></tr>
</tbody></table>
</div>
<p>The code is available in the <code>src/intro</code> directory of the <a href="https://github.com/thedataquarry/rustinpieces/tree/main/src/intro">repo</a>.</p>
<p>Rust's traits don't have a direct equivalent in Python, but they are similar enough to protocols or special methods in that they
allow us to define a set of methods that a type must implement, allowing us to customize the behavior of the type.</p>
<p>Rust embraces functional programming more than Python does, so it has a number of functional constructs that are commonly used.
Where Python prefers list comprehensions, Rust prefers map/filter. Rust's closures, are, at the surface level, similar
enough to Python's lambda functions, but they are also a lot more complex and can be viewed as a superset of anonymous functions.</p>
<p>Hopefully, as you read through the examples, you'll see that Rust and Python are not as different as they may seem at first glance!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="protocols-vs-traits"><a class="header" href="#protocols-vs-traits">Protocols vs. Traits</a></h1>
<p>Python has a concept called protocols, sometimes referred to as special methods, or "dunder methods" implemented on
<a href="https://docs.python.org/3/library/stdtypes.html">built-in types</a> in the standard library.
For example, the <code>__str__</code> method is used to implement the <code>str()</code> function, which returns the string representation of an object.
Th <code>__repr__</code> method is used to implement the <code>repr()</code> function, which returns a string containing a <em>printable representation</em> of an object.</p>
<h2 id="python-protocols"><a class="header" href="#python-protocols">Python: Protocols</a></h2>
<p>In Python, we start by defining a simple <code>Person</code> class that has a name and an age attribute.
To make the output of the <code>print</code> statement more interesting, we implement the following <code>__str__</code> and <code>__repr__</code> methods
that are translated to the <code>str()</code> and <code>repr()</code> functions respectively.</p>
<pre><code class="language-python">class Person:
    def __init__(self, name: str, age: int) -&gt; None:
        self.name = name
        if age &gt; 0 and isinstance(age, int):
            self.age = age
        else:
            raise ValueError("Age must be a positive integer")

    def __str__(self) -&gt; str:
        return f"{self.name} is {self.age} years old"

    def __repr__(self) -&gt; str:
        return f"Person: {self.name}, {self.age}"
</code></pre>
<p>One limitation of Python's type system that's worth noting is that it treats <em>all</em> integers as <code>int</code> types, even if they
are unsigned. In this case, the age of a person should be a positive integer, so we need to check for this by using
an <code>if</code> statement in the class constructor defined in the <code>__init__</code> block. Rust's type system, as we'll see, is
more powerful, while also being stricter than Python's.</p>
<p>We can now create a <code>Person</code> object via a function and print it to the console by running the code via <code>main.py</code>.</p>
<pre><code class="language-python">def run1() -&gt; None:
    person = Person("Megan", 28)
    print(person)
    print(repr(person))
    """
    Megan is 28 years old
    Person: Megan, 28
    """
</code></pre>
<p>When we print the <code>person</code> object, the <code>__str__</code> method is called, and when we print the <code>repr</code> object,
the <code>__repr__</code> method is called, thus producing slightly different outputs depending on what we want to display.
Generally, <code>repr()</code> is used for debugging a stack trace, and <code>str()</code> is used for displaying something to the user.</p>
<h2 id="rust-traits"><a class="header" href="#rust-traits">Rust: Traits</a></h2>
<p>In Rust, we start by defining a <code>Person</code> struct with a name and an age attribute, in a similar way to the Python example.</p>
<pre><code class="language-rs">struct Person {
    name: String,
    age: u8,
}
</code></pre>
<p>Unlike a Python class which always provides <code>__init__</code>, Rust doesn't provide constructors on structs, so we
need to define an implementation block (shown below) for the <code>Person</code> struct via the <code>impl</code> keyword.</p>
<p>As noted earlier, Rust allows us to declare the <code>age</code> variable as an unsigned integer, which is more
appropriate for this use case, eliminating the need to check for positive integers in the constructor.
This makes the code more concise and easier to read in this case.</p>
<pre><code class="language-rs">impl Person {
    fn new(name: &amp;str, age: u8) -&gt; Self {
        Self {
            name: name.to_string(),
            age,
        }
    }
}
</code></pre>
<p>Two things stand out in the <code>impl</code> block defined. We provide an argument <code>&amp;str</code>, which represents a string <em>slice</em>,
and we use the <code>to_string()</code> method to convert the string slice to a <code>String</code> type.</p>
<p>Because Rust is a statically typed language, it needs to know the type and allocation of all variables at compile time.
When we input a person's name during initialization, we don't know how long the name will be. However, arguments to
functions and methods in Rust are passed by reference, so we'd typically use a string slice to represent the name. The
compiler keeps a track of all this, so if you forget to call the <code>to_string()</code> method, you'll get a nice compiler error!</p>
<p>Rust has its own versions of Python's <code>__str__</code> and <code>__repr__</code> methods, but they're called <code>Display</code> and <code>Debug</code> traits.
A trait is similar to an interface in other languages, and vaguely similar to a protocol in Python, because it describes
an object's <em>behavior</em>.</p>
<pre><code class="language-rs">impl fmt::Display for Person {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, "{} is {} years old", self.name, self.age)
    }
}

impl fmt::Debug for Person {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, "Person: {}, {}", self.name, self.age)
    }
}
</code></pre>
<p><code>Display</code> and <code>Debug</code> traits are typically not automatically defined on every object type in Rust, because its
strict type system needs to know upfront what the user wants to do with the object's types prior to displaying them.</p>
<p>With these bits in place, we can now create a <code>Person</code> object via a function and print it to the console by running the code via <code>main.rs</code>.</p>
<pre><code class="language-rs">fn run1() {
    let p = Person::new("Megan", 28);
    println!("{}", p);
    println!("{:?}", p);
    /*
    Megan is 28 years old
    Person: Megan, 28
    */
}
</code></pre>
<p>Note that in Rust, for printing <code>Debug</code> traits, we use the <code>{:?}</code> format specifier, whereas for <code>Display</code> traits, we can just use <code>{}</code>.</p>
<p>The above output is identical to the Python output!</p>
<h2 id="takeaways-1"><a class="header" href="#takeaways-1">Takeaways</a></h2>
<ul>
<li>Rust's type system is stricter and more powerful than Python's, allowing us to define unsigned integers and other types
that are not available in Python's standard library.</li>
<li>Python is object-oriented, so it uses classes in many cases to keep related data and methods together</li>
<li>Rust isn't an object-oriented language and doesn't use classes, but it does have the concept of traits and implementations</li>
<li>In Rust, constructors aren't defined on custom structs, so we need to define the struct's constructor via an implementation
block using the <code>impl</code> keyword.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enumerate"><a class="header" href="#enumerate">Enumerate</a></h1>
<p>In both Python and Rust, the <code>enumerate</code> function exists to
iterate over a list while keeping track of the index of the current item.</p>
<h2 id="python-2"><a class="header" href="#python-2">Python</a></h2>
<p>Recall from the <a href="pieces/intro/../intro/protocols_traits.html#python-protocols">first example</a> that we defined a
<code>Person</code> class with a name and an age attribute.</p>
<p>We can instantiate a list of <code>Person</code> objects and iterate over them using <code>enumerate</code>.</p>
<pre><code class="language-py">def run2() -&gt; None:
    persons = [Person("James", 33), Person("Salima", 31)]
    for i, person in enumerate(persons):
        print(f"Person {i}: {str(person)}")
</code></pre>
<p>Running the above function via <code>main.py</code> gives us the same output as in Rust:</p>
<pre><code class="language-bash">Person 0: James is 33 years old
Person 1: Salima is 31 years old
</code></pre>
<p>The <code>enumerate</code> method returns a tuple of <code>(index, item)</code> for each item in the list,
allowing us to access the index of the current item as we iterate over the list in a <code>for</code> loop.</p>
<h2 id="rust-2"><a class="header" href="#rust-2">Rust</a></h2>
<p>Recall from the <a href="pieces/intro/../intro/protocols_traits.html#rust-traits">first example</a> that we defined a <code>Person</code> struct with a
name and an age attribute, in a similar way to the Python example.</p>
<p>We can instantiate a vector of <code>Person</code> objects and iterate over them using <code>enumerate</code>.</p>
<blockquote>
<p><strong><em>What is a vector?</em></strong>
Like many other languages, Rust provides arrays, but arrays in Rust are fixed-size and allocated
on the stack. Vectors are dynamic arrays that are allocated on the heap, and can grow and shrink
as needed, similar to Python lists.</p>
</blockquote>
<p>For most purposes, vectors in Rust perform the same function as Python lists.
Unlike a Python list, a vector in Rust can only contain objects of the same type, in this case, <code>Person</code>.</p>
<pre><code class="language-rs">fn run2() {
    let persons = vec![Person::new("James", 33), Person::new("Salima", 31)];
    for (i, p) in persons.iter().enumerate() {
        println!("Person {}: {}", i, p)
    }
}
</code></pre>
<p>The <code>vec!</code> macro is syntactic sugar for <code>Vec::new()</code>, which creates a new vector of <code>Person</code> objects.
Additionally, the <code>iter</code> method returns an iterator over the vector, which is required before we can
call the <code>enumerate</code> method on it.</p>
<p>Running the above function via <code>main.rs</code> gives us the same output as in Python:</p>
<pre><code class="language-bash">Person 0: James is 33 years old
Person 1: Salima is 31 years old
</code></pre>
<h2 id="takeaways-2"><a class="header" href="#takeaways-2">Takeaways</a></h2>
<ul>
<li>Both Python and Rust contain a convenience method called <code>enumerate</code> to iterate over a list while keeping
track of the index of the current item.</li>
<li>Python lists are dynamic arrays that can contain objects of <em>any</em> type.</li>
<li>Rust vectors are heap-allocated dynamic arrays that can only contain objects of the <em>same</em> type.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zip"><a class="header" href="#zip">Zip</a></h1>
<p>In both Python and Rust, the <code>zip</code> function exists to construct an iterator over two or more iterables.</p>
<h2 id="python-3"><a class="header" href="#python-3">Python</a></h2>
<p>Recall from the <a href="pieces/intro/../intro/protocols_traits.html#python-protocols">first example</a> that we defined a
<code>Person</code> class with a name and an age attribute.</p>
<p>If we have two lists, one containing names and one containing ages. <code>zip</code> conveniently allows us
to iterate over both lists.</p>
<pre><code class="language-py">def run3() -&gt; None:
    names = ["Alice", "Charlie"]
    ages = [24, 45]
    persons = []
    for name, age in zip(names, ages):
        person = Person(name, age)
        persons.append(person)
    print(f"{repr(persons)}")
</code></pre>
<p>The <code>append</code> method is used to add a new item to the end of the list, similar to <code>push</code> in Rust.</p>
<p>Running the above function via <code>main.py</code> gives us the following output:</p>
<pre><code class="language-bash">[Person('Alice', 24), Person('Charlie', 45)]
</code></pre>
<p>Note that the <code>zip</code> method returns an iterator over tuples of the same length as the <em>shortest</em> iterable passed to it.
So, if we'd passed one list with 3 items and one list with 2 items, the resulting iterator would have 2 items.</p>
<h2 id="rust-3"><a class="header" href="#rust-3">Rust</a></h2>
<p>Recall from the <a href="pieces/intro/../intro/protocols_traits.html#rust-traits">first example</a> that we defined a <code>Person</code> struct with a
name and an age attribute, in a similar way to the Python example.</p>
<p>Consider that we have two vectors, one containing names and one containing ages. <code>zip</code> conveniently allows us
to iterate over both vectors.</p>
<pre><code class="language-rs">fn run3() {
    let names = ["Alice", "Charlie"];
    let ages = [24, 45];
    let mut persons = vec![];
    for (name, age) in names.iter().zip(ages.iter()) {
        persons.push(Person::new(name, *age));
    }
    println!("{:?}", persons);

}
</code></pre>
<ul>
<li>The <code>zip</code> method can only called on an iterator, so we need to call <code>iter</code> on both vectors before we can call <code>zip</code>.</li>
<li>The <code>push</code> method is used to add a new item to the end of the vector, just like <code>append</code> in Python.</li>
</ul>
<p>Again, there's no need to "remember" any of this: the Rust compiler is super helpful in calling you out on common
mistakes, while offering a helpful solution!</p>
<p>Running the function via <code>main.rs</code> gives us the same output as in Python:</p>
<pre><code class="language-bash">[Person: Alice, 24, Person: Charlie, 45]
</code></pre>
<h2 id="takeaways-3"><a class="header" href="#takeaways-3">Takeaways</a></h2>
<p>The functionality of <code>zip</code> is the largely the same in both Python and Rust.</p>
<p>There really aren't too many differences, but it's worth noting that Rust's <code>zip</code> is held to account by the strict type system,
so it's typically only available on iterators (unless you implement your own traits or macros). Python's <code>zip</code> method, on the
other hand, can be called on any iterable (lists, tuples, dictionaries, and so on) because of its dynamic, loosely typed nature.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tuple-unpacking"><a class="header" href="#tuple-unpacking">Tuple unpacking</a></h1>
<p>Both Python and Rust support tuple unpacking in similar ways.</p>
<h3 id="python-4"><a class="header" href="#python-4">Python</a></h3>
<p>Consider the following function in which we unpack the youngest and oldest age from a sorted
list of ages:</p>
<pre><code class="language-python">def run4() -&gt; None:
    sorted_ages = (18, 41, 65)
    youngest, _, oldest = sorted_ages
    print(f"Youngest age: {youngest}, oldest age: {oldest}")
    print(f"Middle age: {sorted_ages[1]}")
</code></pre>
<p>The <code>_</code> is a special variable name in Python that indicates that we don't care about the value,
allowing the unused value to be cleared by the Python memory manager during runtime. We can
still access the middle age via the index operator for tuples, <code>sorted_ages[1]</code>.</p>
<p>Running the above function via <code>main.py</code> gives us the following output:</p>
<pre><code class="language-bash">Youngest age: 18, oldest age: 65
Middle age: 41
</code></pre>
<h3 id="rust-4"><a class="header" href="#rust-4">Rust</a></h3>
<p>We can write the following function in which we unpack the youngest and oldest age from a sorted
list of ages:</p>
<pre><code class="language-rs">fn run4() {
    let sorted_ages: (u8, u8, u8) = (18, 41, 65);
    let (youngest, _, oldest) = sorted_ages;
    println!("Youngest age: {}, oldest age: {}", youngest, oldest);
    println!("Middle age: {}", sorted_ages.1);
}
</code></pre>
<p>Just like in Python, the <code>_</code> indicates that we don't care about the middle value. The difference
is that in Rust, there isn't a garbage collector (or reference counter) like in Python, so the
unused value is only kept in scope till the function is exited. Also, we need to explicitly
declare the type of each age element as unsigned 8-bit integers.</p>
<p>The index operator for tuples in Rust is <code>.</code>, so we can access the middle age via <code>sorted_ages.1</code>.</p>
<p>Running the function via <code>main.rs</code> gives us the same output as in Python:</p>
<pre><code class="language-bash">Youngest age: 18, oldest age: 65
Middle age: 41
</code></pre>
<h2 id="takeaways-4"><a class="header" href="#takeaways-4">Takeaways</a></h2>
<ul>
<li>Tuple unpacking is largely the same in Python and Rust.</li>
<li>There are some minor differences between Python and Rust tuples:
<ul>
<li>In rust, elements of a tuple are mutable, while in Python, they are immutable (lists are
mutable in Python).</li>
<li>In Rust, the index operator for tuples is <code>.</code>, while in Python, it's <code>[]</code>.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lambdas-vs-closures"><a class="header" href="#lambdas-vs-closures">Lambdas vs. closures</a></h1>
<p>Anonymous functions are functions that are not bound to a name. In Python, they are called
<a href="https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions">lambdas</a>. In Rust, they are
called <a href="https://doc.rust-lang.org/book/ch13-01-closures.html">closures</a>. Both are useful for short,one-off functions that are not used anywhere else.</p>
<h2 id="python-5"><a class="header" href="#python-5">Python</a></h2>
<p>Recall from the <a href="pieces/intro/../intro/protocols_traits.html#python-protocols">first example</a> that we defined a
<code>Person</code> class with a name and an age attribute.</p>
<p>In the following example, we use the <code>sorted</code> function to sort a list of <code>Person</code> objects by their
age.</p>
<pre><code class="language-py">def run5() -&gt; None:
    persons = [Person("Aiko", 41), Person("Rohan", 18)]
    sorted_by_age = sorted(persons, key=lambda person: person.age)
    youngest_person = sorted_by_age[0]
    print(f"{youngest_person.name} is the youngest person at {youngest_person.age} years old")
</code></pre>
<p>The <code>sorted</code> function takes an optional <code>key</code> argument, which is a function that is called on each
item in the list to determine the value to sort by. In this case, we use a lambda to return the
<code>age</code> attribute of each <code>Person</code> object.</p>
<pre><code class="language-bash">Rohan is the youngest person at 18 years old
</code></pre>
<h2 id="rust-5"><a class="header" href="#rust-5">Rust</a></h2>
<p>Recall from the <a href="pieces/intro/../intro/protocols_traits.html#rust-traits">first example</a> that we defined a <code>Person</code>
struct with a name and an age attribute, in a similar way to the Python example.</p>
<p>In the following example, we use the <code>sort_by_key</code> method to sort a vector of <code>Person</code> objects by
their age.</p>
<pre><code class="language-rs">fn run5() {
    let mut persons = vec![Person::new("Aiko", 41), Person::new("Rohan", 18)];
    // Sort by age
    persons.sort_by_key(|p| p.age);
    let youngest_person = persons.first().unwrap();
    println!(
        "{} is the youngest person at {} years old",
        youngest_person.name, youngest_person.age
    );
</code></pre>
<p>The <code>sort_by_key</code> method takes a closure that is called on each item in the vector to determine the
value to sort by. In this case, we use a closure operator <code>||</code> to return the <code>age</code> attribute of each
<code>Person</code> object.</p>
<pre><code class="language-bash">Rohan is the youngest person at 18 years old
</code></pre>
<h2 id="takeaways-5"><a class="header" href="#takeaways-5">Takeaways</a></h2>
<ul>
<li>Lambdas and closures are anonymous functions that are not bound to a name, or are passed as
arguments to other functions.</li>
<li>Lambdas and closures are useful for short, one-off functions that are not used anywhere else.</li>
<li>Closures are more powerful than lambdas because they define higher-order functions that can
capture their environment - this is out of scope for this book, but you can read more about it
<a href="https://doc.rust-lang.org/book/ch13-01-closures.html#capturing-the-environment-with-closures">here</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="single-line-if-else"><a class="header" href="#single-line-if-else">Single line if-else</a></h1>
<p>Both Python and Rust support single line if-else statements. This is especially useful when
performing simple operations on a value, allowing for more concise code.</p>
<h2 id="python-6"><a class="header" href="#python-6">Python</a></h2>
<p>Consider the following function in which we print a message depending on whether a person is
born in a leap year or not.</p>
<p>To do this, we first define a function <code>approx_year_of_birth</code> that returns the approximate year.</p>
<pre><code class="language-py">def approx_year_of_birth(person: Person) -&gt; int:
    birth_year_approx = datetime.now().year - person.age
    return birth_year_approx
</code></pre>
<div class="warning">
<p>The leap year logic used above is simplistic and does not account for edge cases.
It's used here purely for the purposes of illustration.</p>
</div>
<p>We can use this function after initializing a list of <code>Person</code> objects.</p>
<pre><code class="language-py">def run6() -&gt; None:
    persons = [Person("Josephine", 20), Person("Wesley", 31)]
    for person in persons:
        # Check if person is born in a leap year using simplistic leap year logic
        birth_year = approx_year_of_birth(person)
        person_is_born_in_leap_year = True if birth_year % 4 == 0 else False
        print(f"{person}. Born in a leap year?: {person_is_born_in_leap_year}")
</code></pre>
<p>Running the above function via <code>main.py</code> gives us the following output:</p>
<pre><code class="language-bash">Josephine is 20 years old. Born in leap year?: True
Wesley is 31 years old. Born in leap year?: False
</code></pre>
<h2 id="rust-6"><a class="header" href="#rust-6">Rust</a></h2>
<p>We can define the below function in Rust, where we print a message depending on whether a person is
born in a leap year or not.</p>
<pre><code class="language-rs">use chrono::prelude::*;

fn approx_year_of_birth(person: &amp;Person) -&gt; u16 {
    let now = chrono::Utc::now();
    let year = now.year() - (person.age as i32);
    year as u16
}
</code></pre>
<p>Note that in Rust, we need to use the <code>chrono</code> crate to handle datetimes, unlike in Python where
the <code>datetime</code> module comes with the standard library.</p>
<p>We then use this function after initializing a vector of <code>Person</code> objects.</p>
<pre><code class="language-rs">fn run6() {
    let persons = vec![Person::new("Josephine", 20), Person::new("Wesley", 31)];
    for person in persons {
        // check if person is born in a leap year using simplistic leap year logic
        let birth_year = approx_year_of_birth(&amp;person);
        let person_is_born_in_leap_year = birth_year % 4 == 0;
        println!(
            "{}. Born in a leap year?: {}",
            person, person_is_born_in_leap_year
        );
    }
</code></pre>
<p>Running the function via <code>main.rs</code> gives us the same output as in Python:</p>
<pre><code class="language-bash">Josephine is 20 years old. Born in a leap year?: true
Wesley is 31 years old. Born in a leap year?: false
</code></pre>
<h2 id="takeaways-6"><a class="header" href="#takeaways-6">Takeaways</a></h2>
<ul>
<li>Single line if-else statements are useful for performing simple operations on a value while
remaining concise.</li>
<li>In certain cases in Rust, we have to use external crates to handle certain functionality that
comes with the standard library in Python.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="list-comprehensions-vs-mapfilter"><a class="header" href="#list-comprehensions-vs-mapfilter">List comprehensions vs map/filter</a></h1>
<p>One of Python's most popular features is its list comprehensions. They are a concise way to create
lists from existing lists. Rust is more functional than Python, so it has a similar feature called
<code>map</code> and <code>filter</code>. Although map and filter functions are availble in Python, they are not as
commonly used as list comprehensions.</p>
<h2 id="python-7"><a class="header" href="#python-7">Python</a></h2>
<p>Consider the following function in which we print a message depending on which persons from
a list of <code>Person</code> objects are born after the year 1995, based on their current age.</p>
<pre><code class="language-py">def run7() -&gt; None:
    """
    1. List comprehensions
    """
    persons = [Person("Issa", 39), Person("Ibrahim", 26)]
    persons_born_after_1995 = [
        (person.name, person.age) for person in persons if approx_year_of_birth(person) &gt; 1995
    ]
    print(f"Persons born after 1995: {persons_born_after_1995}")
</code></pre>
<p>The list comprehension in the above function essentially does the following:</p>
<ol>
<li>Iterate over the list of <code>Person</code> objects</li>
<li>Unpack each <code>Person</code> tuple into their name and age</li>
<li>For each person, check if their approximate year of birth is greater than 1995</li>
</ol>
<p>Running the above function via <code>main.py</code> gives us the following output:</p>
<pre><code class="language-bash">Persons born after 1995: [('Ibrahim', 26)]
</code></pre>
<h2 id="rust-7"><a class="header" href="#rust-7">Rust</a></h2>
<p>We can define the below function in Rust, where we print a message depending on which persons from
a vector of <code>Person</code> objects are born after the year 1995, based on their current age.</p>
<pre><code class="language-rs">fn run7() {
    let persons = vec![Person::new("Issa", 39), Person::new("Ibrahim", 26)];
    let result = persons
        .into_iter()
        .filter(|p| approx_year_of_birth(p) &gt; 1995)
        .map(|p| (p.name, p.age))
        .collect::&lt;Vec&lt;(String, u8)&gt;&gt;();
    println!("Persons born after 1995: {:?}", result)
</code></pre>
<p>The <code>filter</code> and <code>map</code> functions in the above function essentially do the following:</p>
<ol>
<li>Turn the <code>persons</code> vector into an iterator and iterate over the <code>Person</code> objects</li>
<li>For each person, check if their approximate year of birth is greater than 1995</li>
<li>If the above condition is true, then create a tuple of their name and age</li>
<li>Collect all the tuples into a vector of unsigned 8-bit integers</li>
</ol>
<p>Running the function via <code>main.rs</code> gives us the same output as in Python:</p>
<pre><code class="language-bash">Persons born after 1995: [("Ibrahim", 26)]
</code></pre>
<p>The Rust version is a little more verbose than the Python version, but it's still quite readable.</p>
<h2 id="takeaways-7"><a class="header" href="#takeaways-7">Takeaways</a></h2>
<ul>
<li>Both Python and Rust have convenient ways to create iterables without having to use explicit loops.</li>
<li>Python's list comprehensions are more concise than Rust's <code>map</code> and <code>filter</code> functions in
most cases.</li>
<li>Rust's <code>map</code> and <code>filter</code> functions show that Rust is more functional than Python in its syntax.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="dicts-vs-hashmaps"><a class="header" href="#dicts-vs-hashmaps">Dicts vs. hashmaps</a></h2>
<p>Python's <code>dict</code> is essentially a hash table, which is a data structure that maps keys to values.
Rust's <code>HashMap</code> performs the same function. Both are collections of key-value pairs where the
keys must be unique, but the values can be duplicated. The purpose of dicts and hashmaps is to
allow for fast lookup of values by key.</p>
<h2 id="python-8"><a class="header" href="#python-8">Python</a></h2>
<p>Consider the below function in Python, where we define a dictionary of processors and their
corresponding market names.</p>
<pre><code class="language-py">    processors = {
        "13900KS": "Intel Core i9",
        "13700K": "Intel Core i7",
        "13600K": "Intel Core i5",
        "1800X": "AMD Ryzen 7",
        "1600X": "AMD Ryzen 5",
        "1300X": "AMD Ryzen 3",
    }

    # Check for presence of value
    is_item_in_dict = "AMD Ryzen 3" in processors.values()
    print(f'Is "AMD Ryzen 3" in the dict of processors?: {is_item_in_dict}')
    # Lookup by key
    key = "13900KS"
    lookup_by_key = processors[key]
    print(f'Key "{key}" has the value "{lookup_by_key}"')
</code></pre>
<p>The first portion checks for the presence of a value in the dictionary, while the second portion
looks up the value by key.</p>
<p>Running the above function via <code>main.py</code> gives us the following output:</p>
<pre><code class="language-bash">Is "AMD Ryzen 3" in the dict of processors?: True
Key "13900KS" has the value "Intel Core i9"
</code></pre>
<h2 id="rust-8"><a class="header" href="#rust-8">Rust</a></h2>
<p>We define the below function in Rust, where we define a hashmap of processors and their
corresponding market names.</p>
<pre><code class="language-rs">use std::collections::HashMap;

fn run8() {
    let mut processors = HashMap::new();
    processors.insert("13900KS", "Intel Core i9");
    processors.insert("13700K", "Intel Core i7");
    processors.insert("13600K", "Intel Core i5");
    processors.insert("1800X", "AMD Ryzen 7");
    processors.insert("1600X", "AMD Ryzen 5");
    processors.insert("1300X", "AMD Ryzen 3");

    // Check for presence of value
    let value = "AMD Ryzen 3";
    let mut values = processors.values();
    println!(
        "Is \"AMD Ryzen 3\" in the hashmap of processors?: {}",
        values.any(|v| v == &amp;value)
    );
    // Lookup by key
    let key = "13900KS";
    let lookup_by_key = processors.get(key);
    println!(
        "Key \"{}\" has the value \"{}\"",
        key,
        lookup_by_key.unwrap()
    );
}
</code></pre>
<p>Just like in the Python version, the first portion checks for the presence of a value in the
hashmap, while the second portion looks up the value by key.</p>
<p>Running the function via <code>main.rs</code> gives us the same output as in Python:</p>
<pre><code class="language-bash">Is "AMD Ryzen 3" in the hashmap of processors?: true
Key "13900KS" has the value "Intel Core i9"
</code></pre>
<h2 id="takeaways-8"><a class="header" href="#takeaways-8">Takeaways</a></h2>
<p>Python and Rust contain collections that store key-value pairs for fast lookups. A key difference is
that Python's <code>dict</code> keys can be any hashable type and values can be of any
type, but in Rust, <em>both</em> the keys and values of a <code>HashMap</code> must be of the same type.</p>
<p>In Python, this <code>dict</code> is perfectly valid:</p>
<pre><code class="language-py"># You can have a dict with keys of different types
example = {
    "a": 1,
    1: 2
}
</code></pre>
<p>In Rust, the compiler will enforce that the keys and values are of the same type, based on
the first entry's inferred types.</p>
<pre><code class="language-rs">let mut example = HashMap::new();
example.insert("a", 1);
// This errors because the first entry specified the key as &amp;str
example.insert(1, 2);
// This is valid
example.insert("b", 2);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sets-vs-hashsets"><a class="header" href="#sets-vs-hashsets">Sets vs. hashsets</a></h1>
<p>Python's <code>set</code> is an unordered collection of unique items, where duplicate items are not allowed.
Rust's <code>HashSet</code> performs the same function.</p>
<h2 id="python-9"><a class="header" href="#python-9">Python</a></h2>
<p>Consider the following function in which we define a set of processors.</p>
<pre><code class="language-py">def run9() -&gt; None:
    processors = {
        "Intel Core i9",
        "Intel Core i7",
        "Intel Core i5",
        "AMD Ryzen 7",
        "AMD Ryzen 5",
        "AMD Ryzen 3",
    }
    # Duplicate values are ignored
    processors.add("Intel Core i7")
    processors.add("AMD Ryzen 5")
    # Check for presence of value
    is_item_in_set = "AMD Ryzen 3" in processors
    print(f'Is "AMD Ryzen 3" in the set of processors?: {is_item_in_set}')
</code></pre>
<p>The purpose of the above function is to check for the presence of a value in the set of processors.
When we add duplicate values to the set, they are ignored.</p>
<p>Running the above function via <code>main.py</code> gives us the following output:</p>
<pre><code class="language-bash">Is "AMD Ryzen 3" in the set of processors?: True
</code></pre>
<h2 id="rust-9"><a class="header" href="#rust-9">Rust</a></h2>
<p>We define the below function in Rust, where we define a hashset of processors.</p>
<pre><code class="language-rs">use std::collections::HashSet;

fn run9() {
    let mut processors = HashSet::new();
    processors.insert("Intel Core i9");
    processors.insert("Intel Core i7");
    processors.insert("Intel Core i5");
    processors.insert("AMD Ryzen 7");
    processors.insert("AMD Ryzen 5");
    processors.insert("AMD Ryzen 3");
    // Duplicate values are ignored
    processors.insert("Intel Core i7");
    processors.insert("AMD Ryzen 5");
    // Check for presence of value
    let value = "AMD Ryzen 3";
    println!(
        "Is \"AMD Ryzen 3\" in the hashset of processors?: {}",
        processors.contains(&amp;value)
    );
}
</code></pre>
<p>The purpose of the above function is to check for the presence of a value in the hashset of
processors. When we add duplicate values to the hashset, they are ignored.</p>
<p>Running the function via <code>main.rs</code> gives us the same output as in Python:</p>
<pre><code class="language-bash">Is "AMD Ryzen 3" in the hashset of processors?: true
</code></pre>
<h2 id="takeaways-9"><a class="header" href="#takeaways-9">Takeaways</a></h2>
<p>Python and Rust contain collections that allow for the storage of unique items. A key difference is
that Python's <code>set</code> can contain items of any type, while Rust's <code>HashSet</code> can only contain items of
the same type that were specified at the time of initialization.</p>
<p>In Python, the following <code>set</code> containing multiple types is valid, as they are all hashable.</p>
<pre><code class="language-py">example = {1, "hello", 3.14}
</code></pre>
<p>In Rust, the compiler enforces that all items in the set are of the same type specified at the time
of initialization, or by inferring the first value's type.</p>
<pre><code class="language-rs">let example = HashSet::new();
example.insert(1);
// This errors because the first value specified the key as u32 or similar
example.insert("hello");
// This is valid
example.insert(3);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributors"><a class="header" href="#contributors">Contributors</a></h1>
<h2 id="authors"><a class="header" href="#authors">Authors</a></h2>
<p><em>Rust in Pieces</em> is co-authored by <a href="https://github.com/prrao87">Prashanth Rao</a> and <a href="https://github.com/sanders41">Paul Sanders</a>.</p>
<h3 id="about-the-authors"><a class="header" href="#about-the-authors">About the authors</a></h3>
<ul>
<li>
<p><strong>Prashanth Rao</strong> is an A.I. engineer with a background in scientific computing, machine learning, NLP and database systems. He's passionate about making complex topics accessible to a larger audience. In his spare time, Prashanth actively experiments with open source tools, frameworks and databases, and writes about them <a href="https://thedataquarry.com/">on his blog</a>.</p>
</li>
<li>
<p><strong>Paul Sanders</strong> is a software engineer and consultant having spent decades doing data management and application development in healthcare, pharmaceuticals and biologic drug development. In his spare time, Paul loves contributing to open source software and is actively <a href="https://paulsanders.dev/">maintaining several OSS projects</a>.</p>
</li>
</ul>
<h2 id="additional-contributors"><a class="header" href="#additional-contributors">Additional contributors</a></h2>
<p>Contributions and improvements from the community are welcome! Please see the <a href="https://github.com/thedataquarry/rustinpieces/blob/main/CONTRIBUTING.md">contributing guidelines</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
